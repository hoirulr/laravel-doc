<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Helpers - Laravel Docs</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Helpers";
    var mkdocs_page_input_path = "docs-7.x\\helpers.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> Laravel Docs</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../documentation/">Laravel 7.x</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../docs-8.x/documentation/">Laravel 8.x</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">Laravel Docs</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
    
    <li>Helpers</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="helpers">Helpers</h1>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#available-methods">Available Methods</a></li>
</ul>
<p><a name="introduction"></a></p>
<h2 id="introduction">Introduction</h2>
<p>Laravel includes a variety of global "helper" PHP functions. Many of these functions are used by the framework itself; however, you are free to use them in your own applications if you find them convenient.</p>
<p><a name="available-methods"></a></p>
<h2 id="available-methods">Available Methods</h2>
<style>
    .collection-method-list > p {
        column-count: 3; -moz-column-count: 3; -webkit-column-count: 3;
        column-gap: 2em; -moz-column-gap: 2em; -webkit-column-gap: 2em;
    }

    .collection-method-list a {
        display: block;
    }
</style>

<h3 id="arrays-objects">Arrays &amp; Objects</h3>
<div class="collection-method-list" markdown="1">

[Arr::accessible](#method-array-accessible)
[Arr::add](#method-array-add)
[Arr::collapse](#method-array-collapse)
[Arr::crossJoin](#method-array-crossjoin)
[Arr::divide](#method-array-divide)
[Arr::dot](#method-array-dot)
[Arr::except](#method-array-except)
[Arr::exists](#method-array-exists)
[Arr::first](#method-array-first)
[Arr::flatten](#method-array-flatten)
[Arr::forget](#method-array-forget)
[Arr::get](#method-array-get)
[Arr::has](#method-array-has)
[Arr::hasAny](#method-array-hasany)
[Arr::isAssoc](#method-array-isassoc)
[Arr::last](#method-array-last)
[Arr::only](#method-array-only)
[Arr::pluck](#method-array-pluck)
[Arr::prepend](#method-array-prepend)
[Arr::pull](#method-array-pull)
[Arr::query](#method-array-query)
[Arr::random](#method-array-random)
[Arr::set](#method-array-set)
[Arr::shuffle](#method-array-shuffle)
[Arr::sort](#method-array-sort)
[Arr::sortRecursive](#method-array-sort-recursive)
[Arr::where](#method-array-where)
[Arr::wrap](#method-array-wrap)
[data_fill](#method-data-fill)
[data_get](#method-data-get)
[data_set](#method-data-set)
[head](#method-head)
[last](#method-last)
</div>

<h3 id="paths">Paths</h3>
<div class="collection-method-list" markdown="1">

[app_path](#method-app-path)
[base_path](#method-base-path)
[config_path](#method-config-path)
[database_path](#method-database-path)
[mix](#method-mix)
[public_path](#method-public-path)
[resource_path](#method-resource-path)
[storage_path](#method-storage-path)

</div>

<h3 id="strings">Strings</h3>
<div class="collection-method-list" markdown="1">

[\__](#method-__)
[class_basename](#method-class-basename)
[e](#method-e)
[preg_replace_array](#method-preg-replace-array)
[Str::after](#method-str-after)
[Str::afterLast](#method-str-after-last)
[Str::ascii](#method-str-ascii)
[Str::before](#method-str-before)
[Str::beforeLast](#method-str-before-last)
[Str::between](#method-str-between)
[Str::camel](#method-camel-case)
[Str::contains](#method-str-contains)
[Str::containsAll](#method-str-contains-all)
[Str::endsWith](#method-ends-with)
[Str::finish](#method-str-finish)
[Str::is](#method-str-is)
[Str::isAscii](#method-str-is-ascii)
[Str::isUuid](#method-str-is-uuid)
[Str::kebab](#method-kebab-case)
[Str::length](#method-str-length)
[Str::limit](#method-str-limit)
[Str::lower](#method-str-lower)
[Str::orderedUuid](#method-str-ordered-uuid)
[Str::padBoth](#method-str-padboth)
[Str::padLeft](#method-str-padleft)
[Str::padRight](#method-str-padright)
[Str::plural](#method-str-plural)
[Str::random](#method-str-random)
[Str::replaceArray](#method-str-replace-array)
[Str::replaceFirst](#method-str-replace-first)
[Str::replaceLast](#method-str-replace-last)
[Str::singular](#method-str-singular)
[Str::slug](#method-str-slug)
[Str::snake](#method-snake-case)
[Str::start](#method-str-start)
[Str::startsWith](#method-starts-with)
[Str::studly](#method-studly-case)
[Str::substr](#method-str-substr)
[Str::title](#method-title-case)
[Str::ucfirst](#method-str-ucfirst)
[Str::upper](#method-str-upper)
[Str::uuid](#method-str-uuid)
[Str::words](#method-str-words)
[trans](#method-trans)
[trans_choice](#method-trans-choice)

</div>

<p><a name="fluent-strings"></a></p>
<h3 id="fluent-strings">Fluent Strings</h3>
<div class="collection-method-list" markdown="1">

[after](#method-fluent-str-after)
[afterLast](#method-fluent-str-after-last)
[append](#method-fluent-str-append)
[ascii](#method-fluent-str-ascii)
[basename](#method-fluent-str-basename)
[before](#method-fluent-str-before)
[beforeLast](#method-fluent-str-before-last)
[camel](#method-fluent-str-camel)
[contains](#method-fluent-str-contains)
[containsAll](#method-fluent-str-contains-all)
[dirname](#method-fluent-str-dirname)
[endsWith](#method-fluent-str-ends-with)
[exactly](#method-fluent-str-exactly)
[explode](#method-fluent-str-explode)
[finish](#method-fluent-str-finish)
[is](#method-fluent-str-is)
[isAscii](#method-fluent-str-is-ascii)
[isEmpty](#method-fluent-str-is-empty)
[isNotEmpty](#method-fluent-str-is-not-empty)
[kebab](#method-fluent-str-kebab)
[length](#method-fluent-str-length)
[limit](#method-fluent-str-limit)
[lower](#method-fluent-str-lower)
[ltrim](#method-fluent-str-ltrim)
[match](#method-fluent-str-match)
[matchAll](#method-fluent-str-match-all)
[padBoth](#method-fluent-str-padboth)
[padLeft](#method-fluent-str-padleft)
[padRight](#method-fluent-str-padright)
[plural](#method-fluent-str-plural)
[prepend](#method-fluent-str-prepend)
[replace](#method-fluent-str-replace)
[replaceArray](#method-fluent-str-replace-array)
[replaceFirst](#method-fluent-str-replace-first)
[replaceLast](#method-fluent-str-replace-last)
[replaceMatches](#method-fluent-str-replace-matches)
[rtrim](#method-fluent-str-rtrim)
[singular](#method-fluent-str-singular)
[slug](#method-fluent-str-slug)
[snake](#method-fluent-str-snake)
[split](#method-fluent-str-split)
[start](#method-fluent-str-start)
[startsWith](#method-fluent-str-starts-with)
[studly](#method-fluent-str-studly)
[substr](#method-fluent-str-substr)
[title](#method-fluent-str-title)
[trim](#method-fluent-str-trim)
[ucfirst](#method-fluent-str-ucfirst)
[upper](#method-fluent-str-upper)
[when](#method-fluent-str-when)
[whenEmpty](#method-fluent-str-when-empty)
[words](#method-fluent-str-words)

</div>

<h3 id="urls">URLs</h3>
<div class="collection-method-list" markdown="1">

[action](#method-action)
[asset](#method-asset)
[route](#method-route)
[secure_asset](#method-secure-asset)
[secure_url](#method-secure-url)
[url](#method-url)

</div>

<h3 id="miscellaneous">Miscellaneous</h3>
<div class="collection-method-list" markdown="1">

[abort](#method-abort)
[abort_if](#method-abort-if)
[abort_unless](#method-abort-unless)
[app](#method-app)
[auth](#method-auth)
[back](#method-back)
[bcrypt](#method-bcrypt)
[blank](#method-blank)
[broadcast](#method-broadcast)
[cache](#method-cache)
[class_uses_recursive](#method-class-uses-recursive)
[collect](#method-collect)
[config](#method-config)
[cookie](#method-cookie)
[csrf_field](#method-csrf-field)
[csrf_token](#method-csrf-token)
[dd](#method-dd)
[dispatch](#method-dispatch)
[dispatch_now](#method-dispatch-now)
[dump](#method-dump)
[env](#method-env)
[event](#method-event)
[factory](#method-factory)
[filled](#method-filled)
[info](#method-info)
[logger](#method-logger)
[method_field](#method-method-field)
[now](#method-now)
[old](#method-old)
[optional](#method-optional)
[policy](#method-policy)
[redirect](#method-redirect)
[report](#method-report)
[request](#method-request)
[rescue](#method-rescue)
[resolve](#method-resolve)
[response](#method-response)
[retry](#method-retry)
[session](#method-session)
[tap](#method-tap)
[throw_if](#method-throw-if)
[throw_unless](#method-throw-unless)
[today](#method-today)
[trait_uses_recursive](#method-trait-uses-recursive)
[transform](#method-transform)
[validator](#method-validator)
[value](#method-value)
[view](#method-view)
[with](#method-with)

</div>

<p><a name="method-listing"></a></p>
<h2 id="method-listing">Method Listing</h2>
<style>
    #collection-method code {
        font-size: 14px;
    }

    #collection-method:not(.first-collection-method) {
        margin-top: 50px;
    }
</style>

<p><a name="arrays"></a></p>
<h2 id="arrays-objects_1">Arrays &amp; Objects</h2>
<p><a name="method-array-accessible"></a></p>
<h4 id="arraccessible-collection-method-first-collection-method"><code>Arr::accessible()</code> {#collection-method .first-collection-method}</h4>
<p>The <code>Arr::accessible</code> method checks that the given value is array accessible:</p>
<pre><code>use Illuminate\Support\Arr;
use Illuminate\Support\Collection;

$isAccessible = Arr::accessible(['a' =&gt; 1, 'b' =&gt; 2]);

// true

$isAccessible = Arr::accessible(new Collection);

// true

$isAccessible = Arr::accessible('abc');

// false

$isAccessible = Arr::accessible(new stdClass);

// false
</code></pre>
<p><a name="method-array-add"></a></p>
<h4 id="arradd-collection-method"><code>Arr::add()</code> {#collection-method}</h4>
<p>The <code>Arr::add</code> method adds a given key / value pair to an array if the given key doesn't already exist in the array or is set to <code>null</code>:</p>
<pre><code>use Illuminate\Support\Arr;

$array = Arr::add(['name' =&gt; 'Desk'], 'price', 100);

// ['name' =&gt; 'Desk', 'price' =&gt; 100]

$array = Arr::add(['name' =&gt; 'Desk', 'price' =&gt; null], 'price', 100);

// ['name' =&gt; 'Desk', 'price' =&gt; 100]
</code></pre>
<p><a name="method-array-collapse"></a></p>
<h4 id="arrcollapse-collection-method"><code>Arr::collapse()</code> {#collection-method}</h4>
<p>The <code>Arr::collapse</code> method collapses an array of arrays into a single array:</p>
<pre><code>use Illuminate\Support\Arr;

$array = Arr::collapse([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);

// [1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p><a name="method-array-crossjoin"></a></p>
<h4 id="arrcrossjoin-collection-method"><code>Arr::crossJoin()</code> {#collection-method}</h4>
<p>The <code>Arr::crossJoin</code> method cross joins the given arrays, returning a Cartesian product with all possible permutations:</p>
<pre><code>use Illuminate\Support\Arr;

$matrix = Arr::crossJoin([1, 2], ['a', 'b']);

/*
    [
        [1, 'a'],
        [1, 'b'],
        [2, 'a'],
        [2, 'b'],
    ]
*/

$matrix = Arr::crossJoin([1, 2], ['a', 'b'], ['I', 'II']);

/*
    [
        [1, 'a', 'I'],
        [1, 'a', 'II'],
        [1, 'b', 'I'],
        [1, 'b', 'II'],
        [2, 'a', 'I'],
        [2, 'a', 'II'],
        [2, 'b', 'I'],
        [2, 'b', 'II'],
    ]
*/
</code></pre>
<p><a name="method-array-divide"></a></p>
<h4 id="arrdivide-collection-method"><code>Arr::divide()</code> {#collection-method}</h4>
<p>The <code>Arr::divide</code> method returns two arrays, one containing the keys, and the other containing the values of the given array:</p>
<pre><code>use Illuminate\Support\Arr;

[$keys, $values] = Arr::divide(['name' =&gt; 'Desk']);

// $keys: ['name']

// $values: ['Desk']
</code></pre>
<p><a name="method-array-dot"></a></p>
<h4 id="arrdot-collection-method"><code>Arr::dot()</code> {#collection-method}</h4>
<p>The <code>Arr::dot</code> method flattens a multi-dimensional array into a single level array that uses "dot" notation to indicate depth:</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

$flattened = Arr::dot($array);

// ['products.desk.price' =&gt; 100]
</code></pre>
<p><a name="method-array-except"></a></p>
<h4 id="arrexcept-collection-method"><code>Arr::except()</code> {#collection-method}</h4>
<p>The <code>Arr::except</code> method removes the given key / value pairs from an array:</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['name' =&gt; 'Desk', 'price' =&gt; 100];

$filtered = Arr::except($array, ['price']);

// ['name' =&gt; 'Desk']
</code></pre>
<p><a name="method-array-exists"></a></p>
<h4 id="arrexists-collection-method"><code>Arr::exists()</code> {#collection-method}</h4>
<p>The <code>Arr::exists</code> method checks that the given key exists in the provided array:</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['name' =&gt; 'John Doe', 'age' =&gt; 17];

$exists = Arr::exists($array, 'name');

// true

$exists = Arr::exists($array, 'salary');

// false
</code></pre>
<p><a name="method-array-first"></a></p>
<h4 id="arrfirst-collection-method"><code>Arr::first()</code> {#collection-method}</h4>
<p>The <code>Arr::first</code> method returns the first element of an array passing a given truth test:</p>
<pre><code>use Illuminate\Support\Arr;

$array = [100, 200, 300];

$first = Arr::first($array, function ($value, $key) {
    return $value &gt;= 150;
});

// 200
</code></pre>
<p>A default value may also be passed as the third parameter to the method. This value will be returned if no value passes the truth test:</p>
<pre><code>use Illuminate\Support\Arr;

$first = Arr::first($array, $callback, $default);
</code></pre>
<p><a name="method-array-flatten"></a></p>
<h4 id="arrflatten-collection-method"><code>Arr::flatten()</code> {#collection-method}</h4>
<p>The <code>Arr::flatten</code> method flattens a multi-dimensional array into a single level array:</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['name' =&gt; 'Joe', 'languages' =&gt; ['PHP', 'Ruby']];

$flattened = Arr::flatten($array);

// ['Joe', 'PHP', 'Ruby']
</code></pre>
<p><a name="method-array-forget"></a></p>
<h4 id="arrforget-collection-method"><code>Arr::forget()</code> {#collection-method}</h4>
<p>The <code>Arr::forget</code> method removes a given key / value pair from a deeply nested array using "dot" notation:</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

Arr::forget($array, 'products.desk');

// ['products' =&gt; []]
</code></pre>
<p><a name="method-array-get"></a></p>
<h4 id="arrget-collection-method"><code>Arr::get()</code> {#collection-method}</h4>
<p>The <code>Arr::get</code> method retrieves a value from a deeply nested array using "dot" notation:</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

$price = Arr::get($array, 'products.desk.price');

// 100
</code></pre>
<p>The <code>Arr::get</code> method also accepts a default value, which will be returned if the specific key is not found:</p>
<pre><code>use Illuminate\Support\Arr;

$discount = Arr::get($array, 'products.desk.discount', 0);

// 0
</code></pre>
<p><a name="method-array-has"></a></p>
<h4 id="arrhas-collection-method"><code>Arr::has()</code> {#collection-method}</h4>
<p>The <code>Arr::has</code> method checks whether a given item or items exists in an array using "dot" notation:</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['product' =&gt; ['name' =&gt; 'Desk', 'price' =&gt; 100]];

$contains = Arr::has($array, 'product.name');

// true

$contains = Arr::has($array, ['product.price', 'product.discount']);

// false
</code></pre>
<p><a name="method-array-hasany"></a></p>
<h4 id="arrhasany-collection-method"><code>Arr::hasAny()</code> {#collection-method}</h4>
<p>The <code>Arr::hasAny</code> method checks whether any item in a given set exists in an array using "dot" notation:</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['product' =&gt; ['name' =&gt; 'Desk', 'price' =&gt; 100]];

$contains = Arr::hasAny($array, 'product.name');

// true

$contains = Arr::hasAny($array, ['product.name', 'product.discount']);

// true

$contains = Arr::hasAny($array, ['category', 'product.discount']);

// false
</code></pre>
<p><a name="method-array-isassoc"></a></p>
<h4 id="arrisassoc-collection-method"><code>Arr::isAssoc()</code> {#collection-method}</h4>
<p>The <code>Arr::isAssoc</code> returns <code>true</code> if the given array is an associative array. An array is considered "associative" if it doesn't have sequential numerical keys beginning with zero:</p>
<pre><code>use Illuminate\Support\Arr;

$isAssoc = Arr::isAssoc(['product' =&gt; ['name' =&gt; 'Desk', 'price' =&gt; 100]]);

// true

$isAssoc = Arr::isAssoc([1, 2, 3]);

// false
</code></pre>
<p><a name="method-array-last"></a></p>
<h4 id="arrlast-collection-method"><code>Arr::last()</code> {#collection-method}</h4>
<p>The <code>Arr::last</code> method returns the last element of an array passing a given truth test:</p>
<pre><code>use Illuminate\Support\Arr;

$array = [100, 200, 300, 110];

$last = Arr::last($array, function ($value, $key) {
    return $value &gt;= 150;
});

// 300
</code></pre>
<p>A default value may be passed as the third argument to the method. This value will be returned if no value passes the truth test:</p>
<pre><code>use Illuminate\Support\Arr;

$last = Arr::last($array, $callback, $default);
</code></pre>
<p><a name="method-array-only"></a></p>
<h4 id="arronly-collection-method"><code>Arr::only()</code> {#collection-method}</h4>
<p>The <code>Arr::only</code> method returns only the specified key / value pairs from the given array:</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['name' =&gt; 'Desk', 'price' =&gt; 100, 'orders' =&gt; 10];

$slice = Arr::only($array, ['name', 'price']);

// ['name' =&gt; 'Desk', 'price' =&gt; 100]
</code></pre>
<p><a name="method-array-pluck"></a></p>
<h4 id="arrpluck-collection-method"><code>Arr::pluck()</code> {#collection-method}</h4>
<p>The <code>Arr::pluck</code> method retrieves all of the values for a given key from an array:</p>
<pre><code>use Illuminate\Support\Arr;

$array = [
    ['developer' =&gt; ['id' =&gt; 1, 'name' =&gt; 'Taylor']],
    ['developer' =&gt; ['id' =&gt; 2, 'name' =&gt; 'Abigail']],
];

$names = Arr::pluck($array, 'developer.name');

// ['Taylor', 'Abigail']
</code></pre>
<p>You may also specify how you wish the resulting list to be keyed:</p>
<pre><code>use Illuminate\Support\Arr;

$names = Arr::pluck($array, 'developer.name', 'developer.id');

// [1 =&gt; 'Taylor', 2 =&gt; 'Abigail']
</code></pre>
<p><a name="method-array-prepend"></a></p>
<h4 id="arrprepend-collection-method"><code>Arr::prepend()</code> {#collection-method}</h4>
<p>The <code>Arr::prepend</code> method will push an item onto the beginning of an array:</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['one', 'two', 'three', 'four'];

$array = Arr::prepend($array, 'zero');

// ['zero', 'one', 'two', 'three', 'four']
</code></pre>
<p>If needed, you may specify the key that should be used for the value:</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['price' =&gt; 100];

$array = Arr::prepend($array, 'Desk', 'name');

// ['name' =&gt; 'Desk', 'price' =&gt; 100]
</code></pre>
<p><a name="method-array-pull"></a></p>
<h4 id="arrpull-collection-method"><code>Arr::pull()</code> {#collection-method}</h4>
<p>The <code>Arr::pull</code> method returns and removes a key / value pair from an array:</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['name' =&gt; 'Desk', 'price' =&gt; 100];

$name = Arr::pull($array, 'name');

// $name: Desk

// $array: ['price' =&gt; 100]
</code></pre>
<p>A default value may be passed as the third argument to the method. This value will be returned if the key doesn't exist:</p>
<pre><code>use Illuminate\Support\Arr;

$value = Arr::pull($array, $key, $default);
</code></pre>
<p><a name="method-array-query"></a></p>
<h4 id="arrquery-collection-method"><code>Arr::query()</code> {#collection-method}</h4>
<p>The <code>Arr::query</code> method converts the array into a query string:</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['name' =&gt; 'Taylor', 'order' =&gt; ['column' =&gt; 'created_at', 'direction' =&gt; 'desc']];

Arr::query($array);

// name=Taylor&amp;order[column]=created_at&amp;order[direction]=desc
</code></pre>
<p><a name="method-array-random"></a></p>
<h4 id="arrrandom-collection-method"><code>Arr::random()</code> {#collection-method}</h4>
<p>The <code>Arr::random</code> method returns a random value from an array:</p>
<pre><code>use Illuminate\Support\Arr;

$array = [1, 2, 3, 4, 5];

$random = Arr::random($array);

// 4 - (retrieved randomly)
</code></pre>
<p>You may also specify the number of items to return as an optional second argument. Note that providing this argument will return an array, even if only one item is desired:</p>
<pre><code>use Illuminate\Support\Arr;

$items = Arr::random($array, 2);

// [2, 5] - (retrieved randomly)
</code></pre>
<p><a name="method-array-set"></a></p>
<h4 id="arrset-collection-method"><code>Arr::set()</code> {#collection-method}</h4>
<p>The <code>Arr::set</code> method sets a value within a deeply nested array using "dot" notation:</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

Arr::set($array, 'products.desk.price', 200);

// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 200]]]
</code></pre>
<p><a name="method-array-shuffle"></a></p>
<h4 id="arrshuffle-collection-method"><code>Arr::shuffle()</code> {#collection-method}</h4>
<p>The <code>Arr::shuffle</code> method randomly shuffles the items in the array:</p>
<pre><code>use Illuminate\Support\Arr;

$array = Arr::shuffle([1, 2, 3, 4, 5]);

// [3, 2, 5, 1, 4] - (generated randomly)
</code></pre>
<p><a name="method-array-sort"></a></p>
<h4 id="arrsort-collection-method"><code>Arr::sort()</code> {#collection-method}</h4>
<p>The <code>Arr::sort</code> method sorts an array by its values:</p>
<pre><code>use Illuminate\Support\Arr;

$array = ['Desk', 'Table', 'Chair'];

$sorted = Arr::sort($array);

// ['Chair', 'Desk', 'Table']
</code></pre>
<p>You may also sort the array by the results of the given Closure:</p>
<pre><code>use Illuminate\Support\Arr;

$array = [
    ['name' =&gt; 'Desk'],
    ['name' =&gt; 'Table'],
    ['name' =&gt; 'Chair'],
];

$sorted = array_values(Arr::sort($array, function ($value) {
    return $value['name'];
}));

/*
    [
        ['name' =&gt; 'Chair'],
        ['name' =&gt; 'Desk'],
        ['name' =&gt; 'Table'],
    ]
*/
</code></pre>
<p><a name="method-array-sort-recursive"></a></p>
<h4 id="arrsortrecursive-collection-method"><code>Arr::sortRecursive()</code> {#collection-method}</h4>
<p>The <code>Arr::sortRecursive</code> method recursively sorts an array using the <code>sort</code> function for numeric sub=arrays and <code>ksort</code> for associative subarrays:</p>
<pre><code>use Illuminate\Support\Arr;

$array = [
    ['Roman', 'Taylor', 'Li'],
    ['PHP', 'Ruby', 'JavaScript'],
    ['one' =&gt; 1, 'two' =&gt; 2, 'three' =&gt; 3],
];

$sorted = Arr::sortRecursive($array);

/*
    [
        ['JavaScript', 'PHP', 'Ruby'],
        ['one' =&gt; 1, 'three' =&gt; 3, 'two' =&gt; 2],
        ['Li', 'Roman', 'Taylor'],
    ]
*/
</code></pre>
<p><a name="method-array-where"></a></p>
<h4 id="arrwhere-collection-method"><code>Arr::where()</code> {#collection-method}</h4>
<p>The <code>Arr::where</code> method filters an array using the given Closure:</p>
<pre><code>use Illuminate\Support\Arr;

$array = [100, '200', 300, '400', 500];

$filtered = Arr::where($array, function ($value, $key) {
    return is_string($value);
});

// [1 =&gt; '200', 3 =&gt; '400']
</code></pre>
<p><a name="method-array-wrap"></a></p>
<h4 id="arrwrap-collection-method"><code>Arr::wrap()</code> {#collection-method}</h4>
<p>The <code>Arr::wrap</code> method wraps the given value in an array. If the given value is already an array it will not be changed:</p>
<pre><code>use Illuminate\Support\Arr;

$string = 'Laravel';

$array = Arr::wrap($string);

// ['Laravel']
</code></pre>
<p>If the given value is null, an empty array will be returned:</p>
<pre><code>use Illuminate\Support\Arr;

$nothing = null;

$array = Arr::wrap($nothing);

// []
</code></pre>
<p><a name="method-data-fill"></a></p>
<h4 id="data_fill-collection-method"><code>data_fill()</code> {#collection-method}</h4>
<p>The <code>data_fill</code> function sets a missing value within a nested array or object using "dot" notation:</p>
<pre><code>$data = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

data_fill($data, 'products.desk.price', 200);

// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]]

data_fill($data, 'products.desk.discount', 10);

// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100, 'discount' =&gt; 10]]]
</code></pre>
<p>This function also accepts asterisks as wildcards and will fill the target accordingly:</p>
<pre><code>$data = [
    'products' =&gt; [
        ['name' =&gt; 'Desk 1', 'price' =&gt; 100],
        ['name' =&gt; 'Desk 2'],
    ],
];

data_fill($data, 'products.*.price', 200);

/*
    [
        'products' =&gt; [
            ['name' =&gt; 'Desk 1', 'price' =&gt; 100],
            ['name' =&gt; 'Desk 2', 'price' =&gt; 200],
        ],
    ]
*/
</code></pre>
<p><a name="method-data-get"></a></p>
<h4 id="data_get-collection-method"><code>data_get()</code> {#collection-method}</h4>
<p>The <code>data_get</code> function retrieves a value from a nested array or object using "dot" notation:</p>
<pre><code>$data = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

$price = data_get($data, 'products.desk.price');

// 100
</code></pre>
<p>The <code>data_get</code> function also accepts a default value, which will be returned if the specified key is not found:</p>
<pre><code>$discount = data_get($data, 'products.desk.discount', 0);

// 0
</code></pre>
<p>The function also accepts wildcards using asterisks, which may target any key of the array or object:</p>
<pre><code>$data = [
    'product-one' =&gt; ['name' =&gt; 'Desk 1', 'price' =&gt; 100],
    'product-two' =&gt; ['name' =&gt; 'Desk 2', 'price' =&gt; 150],
];

data_get($data, '*.name');

// ['Desk 1', 'Desk 2'];
</code></pre>
<p><a name="method-data-set"></a></p>
<h4 id="data_set-collection-method"><code>data_set()</code> {#collection-method}</h4>
<p>The <code>data_set</code> function sets a value within a nested array or object using "dot" notation:</p>
<pre><code>$data = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

data_set($data, 'products.desk.price', 200);

// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 200]]]
</code></pre>
<p>This function also accepts wildcards and will set values on the target accordingly:</p>
<pre><code>$data = [
    'products' =&gt; [
        ['name' =&gt; 'Desk 1', 'price' =&gt; 100],
        ['name' =&gt; 'Desk 2', 'price' =&gt; 150],
    ],
];

data_set($data, 'products.*.price', 200);

/*
    [
        'products' =&gt; [
            ['name' =&gt; 'Desk 1', 'price' =&gt; 200],
            ['name' =&gt; 'Desk 2', 'price' =&gt; 200],
        ],
    ]
*/
</code></pre>
<p>By default, any existing values are overwritten. If you wish to only set a value if it doesn't exist, you may pass <code>false</code> as the fourth argument:</p>
<pre><code>$data = ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]];

data_set($data, 'products.desk.price', 200, false);

// ['products' =&gt; ['desk' =&gt; ['price' =&gt; 100]]]
</code></pre>
<p><a name="method-head"></a></p>
<h4 id="head-collection-method"><code>head()</code> {#collection-method}</h4>
<p>The <code>head</code> function returns the first element in the given array:</p>
<pre><code>$array = [100, 200, 300];

$first = head($array);

// 100
</code></pre>
<p><a name="method-last"></a></p>
<h4 id="last-collection-method"><code>last()</code> {#collection-method}</h4>
<p>The <code>last</code> function returns the last element in the given array:</p>
<pre><code>$array = [100, 200, 300];

$last = last($array);

// 300
</code></pre>
<p><a name="paths"></a></p>
<h2 id="paths_1">Paths</h2>
<p><a name="method-app-path"></a></p>
<h4 id="app_path-collection-method"><code>app_path()</code> {#collection-method}</h4>
<p>The <code>app_path</code> function returns the fully qualified path to the <code>app</code> directory. You may also use the <code>app_path</code> function to generate a fully qualified path to a file relative to the application directory:</p>
<pre><code>$path = app_path();

$path = app_path('Http/Controllers/Controller.php');
</code></pre>
<p><a name="method-base-path"></a></p>
<h4 id="base_path-collection-method"><code>base_path()</code> {#collection-method}</h4>
<p>The <code>base_path</code> function returns the fully qualified path to the project root. You may also use the <code>base_path</code> function to generate a fully qualified path to a given file relative to the project root directory:</p>
<pre><code>$path = base_path();

$path = base_path('vendor/bin');
</code></pre>
<p><a name="method-config-path"></a></p>
<h4 id="config_path-collection-method"><code>config_path()</code> {#collection-method}</h4>
<p>The <code>config_path</code> function returns the fully qualified path to the <code>config</code> directory. You may also use the <code>config_path</code> function to generate a fully qualified path to a given file within the application's configuration directory:</p>
<pre><code>$path = config_path();

$path = config_path('app.php');
</code></pre>
<p><a name="method-database-path"></a></p>
<h4 id="database_path-collection-method"><code>database_path()</code> {#collection-method}</h4>
<p>The <code>database_path</code> function returns the fully qualified path to the <code>database</code> directory. You may also use the <code>database_path</code> function to generate a fully qualified path to a given file within the database directory:</p>
<pre><code>$path = database_path();

$path = database_path('factories/UserFactory.php');
</code></pre>
<p><a name="method-mix"></a></p>
<h4 id="mix-collection-method"><code>mix()</code> {#collection-method}</h4>
<p>The <code>mix</code> function returns the path to a <a href="/docs/{{version}}/mix">versioned Mix file</a>:</p>
<pre><code>$path = mix('css/app.css');
</code></pre>
<p><a name="method-public-path"></a></p>
<h4 id="public_path-collection-method"><code>public_path()</code> {#collection-method}</h4>
<p>The <code>public_path</code> function returns the fully qualified path to the <code>public</code> directory. You may also use the <code>public_path</code> function to generate a fully qualified path to a given file within the public directory:</p>
<pre><code>$path = public_path();

$path = public_path('css/app.css');
</code></pre>
<p><a name="method-resource-path"></a></p>
<h4 id="resource_path-collection-method"><code>resource_path()</code> {#collection-method}</h4>
<p>The <code>resource_path</code> function returns the fully qualified path to the <code>resources</code> directory. You may also use the <code>resource_path</code> function to generate a fully qualified path to a given file within the resources directory:</p>
<pre><code>$path = resource_path();

$path = resource_path('sass/app.scss');
</code></pre>
<p><a name="method-storage-path"></a></p>
<h4 id="storage_path-collection-method"><code>storage_path()</code> {#collection-method}</h4>
<p>The <code>storage_path</code> function returns the fully qualified path to the <code>storage</code> directory. You may also use the <code>storage_path</code> function to generate a fully qualified path to a given file within the storage directory:</p>
<pre><code>$path = storage_path();

$path = storage_path('app/file.txt');
</code></pre>
<p><a name="strings"></a></p>
<h2 id="strings_1">Strings</h2>
<p><a name="method-__"></a></p>
<h4 id="__-collection-method"><code>__()</code> {#collection-method}</h4>
<p>The <code>__</code> function translates the given translation string or translation key using your <a href="/docs/{{version}}/localization">localization files</a>:</p>
<pre><code>echo __('Welcome to our application');

echo __('messages.welcome');
</code></pre>
<p>If the specified translation string or key does not exist, the <code>__</code> function will return the given value. So, using the example above, the <code>__</code> function would return <code>messages.welcome</code> if that translation key does not exist.</p>
<p><a name="method-class-basename"></a></p>
<h4 id="class_basename-collection-method"><code>class_basename()</code> {#collection-method}</h4>
<p>The <code>class_basename</code> function returns the class name of the given class with the class's namespace removed:</p>
<pre><code>$class = class_basename('Foo\Bar\Baz');

// Baz
</code></pre>
<p><a name="method-e"></a></p>
<h4 id="e-collection-method"><code>e()</code> {#collection-method}</h4>
<p>The <code>e</code> function runs PHP's <code>htmlspecialchars</code> function with the <code>double_encode</code> option set to <code>true</code> by default:</p>
<pre><code>echo e('&lt;html&gt;foo&lt;/html&gt;');

// &amp;lt;html&amp;gt;foo&amp;lt;/html&amp;gt;
</code></pre>
<p><a name="method-preg-replace-array"></a></p>
<h4 id="preg_replace_array-collection-method"><code>preg_replace_array()</code> {#collection-method}</h4>
<p>The <code>preg_replace_array</code> function replaces a given pattern in the string sequentially using an array:</p>
<pre><code>$string = 'The event will take place between :start and :end';

$replaced = preg_replace_array('/:[a-z_]+/', ['8:30', '9:00'], $string);

// The event will take place between 8:30 and 9:00
</code></pre>
<p><a name="method-str-after"></a></p>
<h4 id="strafter-collection-method"><code>Str::after()</code> {#collection-method}</h4>
<p>The <code>Str::after</code> method returns everything after the given value in a string. The entire string will be returned if the value does not exist within the string:</p>
<pre><code>use Illuminate\Support\Str;

$slice = Str::after('This is my name', 'This is');

// ' my name'
</code></pre>
<p><a name="method-str-after-last"></a></p>
<h4 id="strafterlast-collection-method"><code>Str::afterLast()</code> {#collection-method}</h4>
<p>The <code>Str::afterLast</code> method returns everything after the last occurrence of the given value in a string. The entire string will be returned if the value does not exist within the string:</p>
<pre><code>use Illuminate\Support\Str;

$slice = Str::afterLast('App\Http\Controllers\Controller', '\\');

// 'Controller'
</code></pre>
<p><a name="method-str-ascii"></a></p>
<h4 id="strascii-collection-method"><code>Str::ascii()</code> {#collection-method}</h4>
<p>The <code>Str::ascii</code> method will attempt to transliterate the string into an ASCII value:</p>
<pre><code>use Illuminate\Support\Str;

$slice = Str::ascii('û');

// 'u'
</code></pre>
<p><a name="method-str-before"></a></p>
<h4 id="strbefore-collection-method"><code>Str::before()</code> {#collection-method}</h4>
<p>The <code>Str::before</code> method returns everything before the given value in a string:</p>
<pre><code>use Illuminate\Support\Str;

$slice = Str::before('This is my name', 'my name');

// 'This is '
</code></pre>
<p><a name="method-str-before-last"></a></p>
<h4 id="strbeforelast-collection-method"><code>Str::beforeLast()</code> {#collection-method}</h4>
<p>The <code>Str::beforeLast</code> method returns everything before the last occurrence of the given value in a string:</p>
<pre><code>use Illuminate\Support\Str;

$slice = Str::beforeLast('This is my name', 'is');

// 'This '
</code></pre>
<p><a name="method-str-between"></a></p>
<h4 id="strbetween-collection-method"><code>Str::between()</code> {#collection-method}</h4>
<p>The <code>Str::between</code> method returns the portion of a string between two values:</p>
<pre><code>use Illuminate\Support\Str;

$slice = Str::between('This is my name', 'This', 'name');

// ' is my '
</code></pre>
<p><a name="method-camel-case"></a></p>
<h4 id="strcamel-collection-method"><code>Str::camel()</code> {#collection-method}</h4>
<p>The <code>Str::camel</code> method converts the given string to <code>camelCase</code>:</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::camel('foo_bar');

// fooBar
</code></pre>
<p><a name="method-str-contains"></a></p>
<h4 id="strcontains-collection-method"><code>Str::contains()</code> {#collection-method}</h4>
<p>The <code>Str::contains</code> method determines if the given string contains the given value (case sensitive):</p>
<pre><code>use Illuminate\Support\Str;

$contains = Str::contains('This is my name', 'my');

// true
</code></pre>
<p>You may also pass an array of values to determine if the given string contains any of the values:</p>
<pre><code>use Illuminate\Support\Str;

$contains = Str::contains('This is my name', ['my', 'foo']);

// true
</code></pre>
<p><a name="method-str-contains-all"></a></p>
<h4 id="strcontainsall-collection-method"><code>Str::containsAll()</code> {#collection-method}</h4>
<p>The <code>Str::containsAll</code> method determines if the given string contains all array values:</p>
<pre><code>use Illuminate\Support\Str;

$containsAll = Str::containsAll('This is my name', ['my', 'name']);

// true
</code></pre>
<p><a name="method-ends-with"></a></p>
<h4 id="strendswith-collection-method"><code>Str::endsWith()</code> {#collection-method}</h4>
<p>The <code>Str::endsWith</code> method determines if the given string ends with the given value:</p>
<pre><code>use Illuminate\Support\Str;

$result = Str::endsWith('This is my name', 'name');

// true
</code></pre>
<p>You may also pass an array of values to determine if the given string ends with any of the given values:</p>
<pre><code>use Illuminate\Support\Str;

$result = Str::endsWith('This is my name', ['name', 'foo']);

// true

$result = Str::endsWith('This is my name', ['this', 'foo']);

// false
</code></pre>
<p><a name="method-str-finish"></a></p>
<h4 id="strfinish-collection-method"><code>Str::finish()</code> {#collection-method}</h4>
<p>The <code>Str::finish</code> method adds a single instance of the given value to a string if it does not already end with the value:</p>
<pre><code>use Illuminate\Support\Str;

$adjusted = Str::finish('this/string', '/');

// this/string/

$adjusted = Str::finish('this/string/', '/');

// this/string/
</code></pre>
<p><a name="method-str-is"></a></p>
<h4 id="stris-collection-method"><code>Str::is()</code> {#collection-method}</h4>
<p>The <code>Str::is</code> method determines if a given string matches a given pattern. Asterisks may be used to indicate wildcards:</p>
<pre><code>use Illuminate\Support\Str;

$matches = Str::is('foo*', 'foobar');

// true

$matches = Str::is('baz*', 'foobar');

// false
</code></pre>
<p><a name="method-str-is-ascii"></a></p>
<h4 id="strisascii-collection-method"><code>Str::isAscii()</code> {#collection-method}</h4>
<p>The <code>Str::isAscii</code> method determines if a given string is 7 bit ASCII:</p>
<pre><code>use Illuminate\Support\Str;

$isAscii = Str::isAscii('Taylor');

// true

$isAscii = Str::isAscii('ü');

// false
</code></pre>
<p><a name="method-str-is-uuid"></a></p>
<h4 id="strisuuid-collection-method"><code>Str::isUuid()</code> {#collection-method}</h4>
<p>The <code>Str::isUuid</code> method determines if the given string is a valid UUID:</p>
<pre><code>use Illuminate\Support\Str;

$isUuid = Str::isUuid('a0a2a2d2-0b87-4a18-83f2-2529882be2de');

// true

$isUuid = Str::isUuid('laravel');

// false
</code></pre>
<p><a name="method-kebab-case"></a></p>
<h4 id="strkebab-collection-method"><code>Str::kebab()</code> {#collection-method}</h4>
<p>The <code>Str::kebab</code> method converts the given string to <code>kebab-case</code>:</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::kebab('fooBar');

// foo-bar
</code></pre>
<p><a name="method-str-length"></a></p>
<h4 id="strlength-collection-method"><code>Str::length()</code> {#collection-method}</h4>
<p>The <code>Str::length</code> method returns the length of the given string:</p>
<pre><code>use Illuminate\Support\Str;

$length = Str::length('Laravel');

// 7
</code></pre>
<p><a name="method-str-limit"></a></p>
<h4 id="strlimit-collection-method"><code>Str::limit()</code> {#collection-method}</h4>
<p>The <code>Str::limit</code> method truncates the given string at the specified length:</p>
<pre><code>use Illuminate\Support\Str;

$truncated = Str::limit('The quick brown fox jumps over the lazy dog', 20);

// The quick brown fox...
</code></pre>
<p>You may also pass a third argument to change the string that will be appended to the end:</p>
<pre><code>use Illuminate\Support\Str;

$truncated = Str::limit('The quick brown fox jumps over the lazy dog', 20, ' (...)');

// The quick brown fox (...)
</code></pre>
<p><a name="method-str-lower"></a></p>
<h4 id="strlower-collection-method"><code>Str::lower()</code> {#collection-method}</h4>
<p>The <code>Str::lower</code> method converts the given string to lowercase:</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::lower('LARAVEL');

// laravel
</code></pre>
<p><a name="method-str-ordered-uuid"></a></p>
<h4 id="strordereduuid-collection-method"><code>Str::orderedUuid()</code> {#collection-method}</h4>
<p>The <code>Str::orderedUuid</code> method generates a "timestamp first" UUID that may be efficiently stored in an indexed database column:</p>
<pre><code>use Illuminate\Support\Str;

return (string) Str::orderedUuid();
</code></pre>
<p><a name="method-str-padboth"></a></p>
<h4 id="strpadboth-collection-method"><code>Str::padBoth()</code> {#collection-method}</h4>
<p>The <code>Str::padBoth</code> method wraps PHP's <code>str_pad</code> function, padding both sides of a string with another:</p>
<pre><code>use Illuminate\Support\Str;

$padded = Str::padBoth('James', 10, '_');

// '__James___'

$padded = Str::padBoth('James', 10);

// '  James   '
</code></pre>
<p><a name="method-str-padleft"></a></p>
<h4 id="strpadleft-collection-method"><code>Str::padLeft()</code> {#collection-method}</h4>
<p>The <code>Str::padLeft</code> method wraps PHP's <code>str_pad</code> function, padding the left side of a string with another:</p>
<pre><code>use Illuminate\Support\Str;

$padded = Str::padLeft('James', 10, '-=');

// '-=-=-James'

$padded = Str::padLeft('James', 10);

// '     James'
</code></pre>
<p><a name="method-str-padright"></a></p>
<h4 id="strpadright-collection-method"><code>Str::padRight()</code> {#collection-method}</h4>
<p>The <code>Str::padRight</code> method wraps PHP's <code>str_pad</code> function, padding the right side of a string with another:</p>
<pre><code>use Illuminate\Support\Str;

$padded = Str::padRight('James', 10, '-');

// 'James-----'

$padded = Str::padRight('James', 10);

// 'James     '
</code></pre>
<p><a name="method-str-plural"></a></p>
<h4 id="strplural-collection-method"><code>Str::plural()</code> {#collection-method}</h4>
<p>The <code>Str::plural</code> method converts a single word string to its plural form. This function currently only supports the English language:</p>
<pre><code>use Illuminate\Support\Str;

$plural = Str::plural('car');

// cars

$plural = Str::plural('child');

// children
</code></pre>
<p>You may provide an integer as a second argument to the function to retrieve the singular or plural form of the string:</p>
<pre><code>use Illuminate\Support\Str;

$plural = Str::plural('child', 2);

// children

$plural = Str::plural('child', 1);

// child
</code></pre>
<p><a name="method-str-random"></a></p>
<h4 id="strrandom-collection-method"><code>Str::random()</code> {#collection-method}</h4>
<p>The <code>Str::random</code> method generates a random string of the specified length. This function uses PHP's <code>random_bytes</code> function:</p>
<pre><code>use Illuminate\Support\Str;

$random = Str::random(40);
</code></pre>
<p><a name="method-str-replace-array"></a></p>
<h4 id="strreplacearray-collection-method"><code>Str::replaceArray()</code> {#collection-method}</h4>
<p>The <code>Str::replaceArray</code> method replaces a given value in the string sequentially using an array:</p>
<pre><code>use Illuminate\Support\Str;

$string = 'The event will take place between ? and ?';

$replaced = Str::replaceArray('?', ['8:30', '9:00'], $string);

// The event will take place between 8:30 and 9:00
</code></pre>
<p><a name="method-str-replace-first"></a></p>
<h4 id="strreplacefirst-collection-method"><code>Str::replaceFirst()</code> {#collection-method}</h4>
<p>The <code>Str::replaceFirst</code> method replaces the first occurrence of a given value in a string:</p>
<pre><code>use Illuminate\Support\Str;

$replaced = Str::replaceFirst('the', 'a', 'the quick brown fox jumps over the lazy dog');

// a quick brown fox jumps over the lazy dog
</code></pre>
<p><a name="method-str-replace-last"></a></p>
<h4 id="strreplacelast-collection-method"><code>Str::replaceLast()</code> {#collection-method}</h4>
<p>The <code>Str::replaceLast</code> method replaces the last occurrence of a given value in a string:</p>
<pre><code>use Illuminate\Support\Str;

$replaced = Str::replaceLast('the', 'a', 'the quick brown fox jumps over the lazy dog');

// the quick brown fox jumps over a lazy dog
</code></pre>
<p><a name="method-str-singular"></a></p>
<h4 id="strsingular-collection-method"><code>Str::singular()</code> {#collection-method}</h4>
<p>The <code>Str::singular</code> method converts a string to its singular form. This function currently only supports the English language:</p>
<pre><code>use Illuminate\Support\Str;

$singular = Str::singular('cars');

// car

$singular = Str::singular('children');

// child
</code></pre>
<p><a name="method-str-slug"></a></p>
<h4 id="strslug-collection-method"><code>Str::slug()</code> {#collection-method}</h4>
<p>The <code>Str::slug</code> method generates a URL friendly "slug" from the given string:</p>
<pre><code>use Illuminate\Support\Str;

$slug = Str::slug('Laravel 5 Framework', '-');

// laravel-5-framework
</code></pre>
<p><a name="method-snake-case"></a></p>
<h4 id="strsnake-collection-method"><code>Str::snake()</code> {#collection-method}</h4>
<p>The <code>Str::snake</code> method converts the given string to <code>snake_case</code>:</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::snake('fooBar');

// foo_bar
</code></pre>
<p><a name="method-str-start"></a></p>
<h4 id="strstart-collection-method"><code>Str::start()</code> {#collection-method}</h4>
<p>The <code>Str::start</code> method adds a single instance of the given value to a string if it does not already start with the value:</p>
<pre><code>use Illuminate\Support\Str;

$adjusted = Str::start('this/string', '/');

// /this/string

$adjusted = Str::start('/this/string', '/');

// /this/string
</code></pre>
<p><a name="method-starts-with"></a></p>
<h4 id="strstartswith-collection-method"><code>Str::startsWith()</code> {#collection-method}</h4>
<p>The <code>Str::startsWith</code> method determines if the given string begins with the given value:</p>
<pre><code>use Illuminate\Support\Str;

$result = Str::startsWith('This is my name', 'This');

// true
</code></pre>
<p><a name="method-studly-case"></a></p>
<h4 id="strstudly-collection-method"><code>Str::studly()</code> {#collection-method}</h4>
<p>The <code>Str::studly</code> method converts the given string to <code>StudlyCase</code>:</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::studly('foo_bar');

// FooBar
</code></pre>
<p><a name="method-str-substr"></a></p>
<h4 id="strsubstr-collection-method"><code>Str::substr()</code> {#collection-method}</h4>
<p>The <code>Str::substr</code> method returns the portion of string specified by the start and length parameters:</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::substr('The Laravel Framework', 4, 7);

// Laravel
</code></pre>
<p><a name="method-title-case"></a></p>
<h4 id="strtitle-collection-method"><code>Str::title()</code> {#collection-method}</h4>
<p>The <code>Str::title</code> method converts the given string to <code>Title Case</code>:</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::title('a nice title uses the correct case');

// A Nice Title Uses The Correct Case
</code></pre>
<p><a name="method-str-ucfirst"></a></p>
<h4 id="strucfirst-collection-method"><code>Str::ucfirst()</code> {#collection-method}</h4>
<p>The <code>Str::ucfirst</code> method returns the given string with the first character capitalized:</p>
<pre><code>use Illuminate\Support\Str;

$string = Str::ucfirst('foo bar');

// Foo bar
</code></pre>
<p><a name="method-str-upper"></a></p>
<h4 id="strupper-collection-method"><code>Str::upper()</code> {#collection-method}</h4>
<p>The <code>Str::upper</code> method converts the given string to uppercase:</p>
<pre><code>use Illuminate\Support\Str;

$string = Str::upper('laravel');

// LARAVEL
</code></pre>
<p><a name="method-str-uuid"></a></p>
<h4 id="struuid-collection-method"><code>Str::uuid()</code> {#collection-method}</h4>
<p>The <code>Str::uuid</code> method generates a UUID (version 4):</p>
<pre><code>use Illuminate\Support\Str;

return (string) Str::uuid();
</code></pre>
<p><a name="method-str-words"></a></p>
<h4 id="strwords-collection-method"><code>Str::words()</code> {#collection-method}</h4>
<p>The <code>Str::words</code> method limits the number of words in a string:</p>
<pre><code>use Illuminate\Support\Str;

return Str::words('Perfectly balanced, as all things should be.', 3, ' &gt;&gt;&gt;');

// Perfectly balanced, as &gt;&gt;&gt;
</code></pre>
<p><a name="method-trans"></a></p>
<h4 id="trans-collection-method"><code>trans()</code> {#collection-method}</h4>
<p>The <code>trans</code> function translates the given translation key using your <a href="/docs/{{version}}/localization">localization files</a>:</p>
<pre><code>echo trans('messages.welcome');
</code></pre>
<p>If the specified translation key does not exist, the <code>trans</code> function will return the given key. So, using the example above, the <code>trans</code> function would return <code>messages.welcome</code> if the translation key does not exist.</p>
<p><a name="method-trans-choice"></a></p>
<h4 id="trans_choice-collection-method"><code>trans_choice()</code> {#collection-method}</h4>
<p>The <code>trans_choice</code> function translates the given translation key with inflection:</p>
<pre><code>echo trans_choice('messages.notifications', $unreadCount);
</code></pre>
<p>If the specified translation key does not exist, the <code>trans_choice</code> function will return the given key. So, using the example above, the <code>trans_choice</code> function would return <code>messages.notifications</code> if the translation key does not exist.</p>
<p><a name="fluent-strings"></a></p>
<h2 id="fluent-strings_1">Fluent Strings</h2>
<p>Fluent strings provide a more fluent, object-oriented interface for working with string values, allowing you to chain multiple string operations together using a more readable syntax compared to traditional string operations.</p>
<p><a name="method-fluent-str-after"></a></p>
<h4 id="after-collection-method"><code>after</code> {#collection-method}</h4>
<p>The <code>after</code> method returns everything after the given value in a string. The entire string will be returned if the value does not exist within the string:</p>
<pre><code>use Illuminate\Support\Str;

$slice = Str::of('This is my name')-&gt;after('This is');

// ' my name'
</code></pre>
<p><a name="method-fluent-str-after-last"></a></p>
<h4 id="afterlast-collection-method"><code>afterLast</code> {#collection-method}</h4>
<p>The <code>afterLast</code> method returns everything after the last occurrence of the given value in a string. The entire string will be returned if the value does not exist within the string:</p>
<pre><code>use Illuminate\Support\Str;

$slice = Str::of('App\Http\Controllers\Controller')-&gt;afterLast('\\');

// 'Controller'
</code></pre>
<p><a name="method-fluent-str-append"></a></p>
<h4 id="append-collection-method"><code>append</code> {#collection-method}</h4>
<p>The <code>append</code> method appends the given values to the string:</p>
<pre><code>use Illuminate\Support\Str;

$string = Str::of('Taylor')-&gt;append(' Otwell');

// 'Taylor Otwell'
</code></pre>
<p><a name="method-fluent-str-ascii"></a></p>
<h4 id="ascii-collection-method"><code>ascii</code> {#collection-method}</h4>
<p>The <code>ascii</code> method will attempt to transliterate the string into an ASCII value:</p>
<pre><code>use Illuminate\Support\Str;

$string = Str::of('ü')-&gt;ascii();

// 'u'
</code></pre>
<p><a name="method-fluent-str-basename"></a></p>
<h4 id="basename-collection-method"><code>basename</code> {#collection-method}</h4>
<p>The <code>basename</code> method will return the trailing name component of the given string:</p>
<pre><code>use Illuminate\Support\Str;

$string = Str::of('/foo/bar/baz')-&gt;basename();

// 'baz'
</code></pre>
<p>If needed, you may provide an "extension" that will be removed from the trailing component:</p>
<pre><code>use Illuminate\Support\Str;

$string = Str::of('/foo/bar/baz.jpg')-&gt;basename('.jpg');

// 'baz'
</code></pre>
<p><a name="method-fluent-str-before"></a></p>
<h4 id="before-collection-method"><code>before</code> {#collection-method}</h4>
<p>The <code>before</code> method returns everything before the given value in a string:</p>
<pre><code>use Illuminate\Support\Str;

$slice = Str::of('This is my name')-&gt;before('my name');

// 'This is '
</code></pre>
<p><a name="method-fluent-str-before-last"></a></p>
<h4 id="beforelast-collection-method"><code>beforeLast</code> {#collection-method}</h4>
<p>The <code>beforeLast</code> method returns everything before the last occurrence of the given value in a string:</p>
<pre><code>use Illuminate\Support\Str;

$slice = Str::of('This is my name')-&gt;beforeLast('is');

// 'This '
</code></pre>
<p><a name="method-fluent-str-camel"></a></p>
<h4 id="camel-collection-method"><code>camel</code> {#collection-method}</h4>
<p>The <code>camel</code> method converts the given string to <code>camelCase</code>:</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::of('foo_bar')-&gt;camel();

// fooBar
</code></pre>
<p><a name="method-fluent-str-contains"></a></p>
<h4 id="contains-collection-method"><code>contains</code> {#collection-method}</h4>
<p>The <code>contains</code> method determines if the given string contains the given value (case sensitive):</p>
<pre><code>use Illuminate\Support\Str;

$contains = Str::of('This is my name')-&gt;contains('my');

// true
</code></pre>
<p>You may also pass an array of values to determine if the given string contains any of the values:</p>
<pre><code>use Illuminate\Support\Str;

$contains = Str::of('This is my name')-&gt;contains(['my', 'foo']);

// true
</code></pre>
<p><a name="method-fluent-str-contains-all"></a></p>
<h4 id="containsall-collection-method"><code>containsAll</code> {#collection-method}</h4>
<p>The <code>containsAll</code> method determines if the given string contains all array values:</p>
<pre><code>use Illuminate\Support\Str;

$containsAll = Str::of('This is my name')-&gt;containsAll(['my', 'name']);

// true
</code></pre>
<p><a name="method-fluent-str-dirname"></a></p>
<h4 id="dirname-collection-method"><code>dirname</code> {#collection-method}</h4>
<p>The <code>dirname</code> method returns the parent directory portion of the given string:</p>
<pre><code>use Illuminate\Support\Str;

$string = Str::of('/foo/bar/baz')-&gt;dirname();

// '/foo/bar'
</code></pre>
<p>Optionally, You may specify how many directory levels you wish to trim from the string:</p>
<pre><code>use Illuminate\Support\Str;

$string = Str::of('/foo/bar/baz')-&gt;dirname(2);

// '/foo'
</code></pre>
<p><a name="method-fluent-str-ends-with"></a></p>
<h4 id="endswith-collection-method"><code>endsWith</code> {#collection-method}</h4>
<p>The <code>endsWith</code> method determines if the given string ends with the given value:</p>
<pre><code>use Illuminate\Support\Str;

$result = Str::of('This is my name')-&gt;endsWith('name');

// true
</code></pre>
<p>You may also pass an array of values to determine if the given string ends with any of the given values:</p>
<pre><code>use Illuminate\Support\Str;

$result = Str::of('This is my name')-&gt;endsWith(['name', 'foo']);

// true

$result = Str::of('This is my name')-&gt;endsWith(['this', 'foo']);

// false
</code></pre>
<p><a name="method-fluent-str-exactly"></a></p>
<h4 id="exactly-collection-method"><code>exactly</code> {#collection-method}</h4>
<p>The <code>exactly</code> method determines if the given string is an exact match with another string:</p>
<pre><code>use Illuminate\Support\Str;

$result = Str::of('Laravel')-&gt;exactly('Laravel');

// true
</code></pre>
<p><a name="method-fluent-str-explode"></a></p>
<h4 id="explode-collection-method"><code>explode</code> {#collection-method}</h4>
<p>The <code>explode</code> method splits the string by the given delimiter and returns a collection containing each section of the split string:</p>
<pre><code>use Illuminate\Support\Str;

$collection = Str::of('foo bar baz')-&gt;explode(' ');

// collect(['foo', 'bar', 'baz'])
</code></pre>
<p><a name="method-fluent-str-finish"></a></p>
<h4 id="finish-collection-method"><code>finish</code> {#collection-method}</h4>
<p>The <code>finish</code> method adds a single instance of the given value to a string if it does not already end with the value:</p>
<pre><code>use Illuminate\Support\Str;

$adjusted = Str::of('this/string')-&gt;finish('/');

// this/string/

$adjusted = Str::of('this/string/')-&gt;finish('/');

// this/string/
</code></pre>
<p><a name="method-fluent-str-is"></a></p>
<h4 id="is-collection-method"><code>is</code> {#collection-method}</h4>
<p>The <code>is</code> method determines if a given string matches a given pattern. Asterisks may be used to indicate wildcards:</p>
<pre><code>use Illuminate\Support\Str;

$matches = Str::of('foobar')-&gt;is('foo*');

// true

$matches = Str::of('foobar')-&gt;is('baz*');

// false
</code></pre>
<p><a name="method-fluent-str-is-ascii"></a></p>
<h4 id="isascii-collection-method"><code>isAscii</code> {#collection-method}</h4>
<p>The <code>isAscii</code> method determines if a given string is an ASCII string:</p>
<pre><code>use Illuminate\Support\Str;

$result = Str::of('Taylor')-&gt;isAscii();

// true

$result = Str::of('ü')-&gt;isAscii();

// false
</code></pre>
<p><a name="method-fluent-str-is-empty"></a></p>
<h4 id="isempty-collection-method"><code>isEmpty</code> {#collection-method}</h4>
<p>The <code>isEmpty</code> method determines if the given string is empty:</p>
<pre><code>use Illuminate\Support\Str;

$result = Str::of('  ')-&gt;trim()-&gt;isEmpty();

// true

$result = Str::of('Laravel')-&gt;trim()-&gt;isEmpty();

// false
</code></pre>
<p><a name="method-fluent-str-is-not-empty"></a></p>
<h4 id="isnotempty-collection-method"><code>isNotEmpty</code> {#collection-method}</h4>
<p>The <code>isNotEmpty</code> method determines if the given string is not empty:</p>
<pre><code>use Illuminate\Support\Str;

$result = Str::of('  ')-&gt;trim()-&gt;isNotEmpty();

// false

$result = Str::of('Laravel')-&gt;trim()-&gt;isNotEmpty();

// true
</code></pre>
<p><a name="method-fluent-str-kebab"></a></p>
<h4 id="kebab-collection-method"><code>kebab</code> {#collection-method}</h4>
<p>The <code>kebab</code> method converts the given string to <code>kebab-case</code>:</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::of('fooBar')-&gt;kebab();

// foo-bar
</code></pre>
<p><a name="method-fluent-str-length"></a></p>
<h4 id="length-collection-method"><code>length</code> {#collection-method}</h4>
<p>The <code>length</code> method returns the length of the given string:</p>
<pre><code>use Illuminate\Support\Str;

$length = Str::of('Laravel')-&gt;length();

// 7
</code></pre>
<p><a name="method-fluent-str-limit"></a></p>
<h4 id="limit-collection-method"><code>limit</code> {#collection-method}</h4>
<p>The <code>limit</code> method truncates the given string at the specified length:</p>
<pre><code>use Illuminate\Support\Str;

$truncated = Str::of('The quick brown fox jumps over the lazy dog')-&gt;limit(20);

// The quick brown fox...
</code></pre>
<p>You may also pass a second argument to change the string that will be appended to the end:</p>
<pre><code>use Illuminate\Support\Str;

$truncated = Str::of('The quick brown fox jumps over the lazy dog')-&gt;limit(20, ' (...)');

// The quick brown fox (...)
</code></pre>
<p><a name="method-fluent-str-lower"></a></p>
<h4 id="lower-collection-method"><code>lower</code> {#collection-method}</h4>
<p>The <code>lower</code> method converts the given string to lowercase:</p>
<pre><code>use Illuminate\Support\Str;

$result = Str::of('LARAVEL')-&gt;lower();

// 'laravel'
</code></pre>
<p><a name="method-fluent-str-ltrim"></a></p>
<h4 id="ltrim-collection-method"><code>ltrim</code> {#collection-method}</h4>
<p>The <code>ltrim</code> method left trims the given string:</p>
<pre><code>use Illuminate\Support\Str;

$string = Str::of('  Laravel  ')-&gt;ltrim();

// 'Laravel  '

$string = Str::of('/Laravel/')-&gt;ltrim('/');

// 'Laravel/'
</code></pre>
<p><a name="method-fluent-str-match"></a></p>
<h4 id="match-collection-method"><code>match</code> {#collection-method}</h4>
<p>The <code>match</code> method will return the portion of a string that matches a given regular expression pattern:</p>
<pre><code>use Illuminate\Support\Str;

$result = Str::of('foo bar')-&gt;match('/bar/');

// 'bar'

$result = Str::of('foo bar')-&gt;match('/foo (.*)/');

// 'bar'
</code></pre>
<p><a name="method-fluent-str-match-all"></a></p>
<h4 id="matchall-collection-method"><code>matchAll</code> {#collection-method}</h4>
<p>The <code>matchAll</code> method will return a collection containing the portions of a string that match a given regular expression pattern:</p>
<pre><code>use Illuminate\Support\Str;

$result = Str::of('bar foo bar')-&gt;matchAll('/bar/');

// collect(['bar', 'bar'])
</code></pre>
<p>If you specify a matching group within the expression, Laravel will return a collection of that group's matches:</p>
<pre><code>use Illuminate\Support\Str;

$result = Str::of('bar fun bar fly')-&gt;matchAll('/f(\w*)/');

// collect(['un', 'ly']);
</code></pre>
<p>If no matches are found, an empty collection will be returned.</p>
<p><a name="method-fluent-str-padboth"></a></p>
<h4 id="padboth-collection-method"><code>padBoth</code> {#collection-method}</h4>
<p>The <code>padBoth</code> method wraps PHP's <code>str_pad</code> function, padding both sides of a string with another:</p>
<pre><code>use Illuminate\Support\Str;

$padded = Str::of('James')-&gt;padBoth(10, '_');

// '__James___'

$padded = Str::of('James')-&gt;padBoth(10);

// '  James   '
</code></pre>
<p><a name="method-fluent-str-padleft"></a></p>
<h4 id="padleft-collection-method"><code>padLeft</code> {#collection-method}</h4>
<p>The <code>padLeft</code> method wraps PHP's <code>str_pad</code> function, padding the left side of a string with another:</p>
<pre><code>use Illuminate\Support\Str;

$padded = Str::of('James')-&gt;padLeft(10, '-=');

// '-=-=-James'

$padded = Str::of('James')-&gt;padLeft(10);

// '     James'
</code></pre>
<p><a name="method-fluent-str-padright"></a></p>
<h4 id="padright-collection-method"><code>padRight</code> {#collection-method}</h4>
<p>The <code>padRight</code> method wraps PHP's <code>str_pad</code> function, padding the right side of a string with another:</p>
<pre><code>use Illuminate\Support\Str;

$padded = Str::of('James')-&gt;padRight(10, '-');

// 'James-----'

$padded = Str::of('James')-&gt;padRight(10);

// 'James     '
</code></pre>
<p><a name="method-fluent-str-plural"></a></p>
<h4 id="plural-collection-method"><code>plural</code> {#collection-method}</h4>
<p>The <code>plural</code> method converts a single word string to its plural form. This function currently only supports the English language:</p>
<pre><code>use Illuminate\Support\Str;

$plural = Str::of('car')-&gt;plural();

// cars

$plural = Str::of('child')-&gt;plural();

// children
</code></pre>
<p>You may provide an integer as a second argument to the function to retrieve the singular or plural form of the string:</p>
<pre><code>use Illuminate\Support\Str;

$plural = Str::of('child')-&gt;plural(2);

// children

$plural = Str::of('child')-&gt;plural(1);

// child
</code></pre>
<p><a name="method-fluent-str-prepend"></a></p>
<h4 id="prepend-collection-method"><code>prepend</code> {#collection-method}</h4>
<p>The <code>prepend</code> method prepends the given values onto the string:</p>
<pre><code>use Illuminate\Support\Str;

$string = Str::of('Framework')-&gt;prepend('Laravel ');

// Laravel Framework
</code></pre>
<p><a name="method-fluent-str-replace"></a></p>
<h4 id="replace-collection-method"><code>replace</code> {#collection-method}</h4>
<p>The <code>replace</code> method replaces a given string within the string:</p>
<pre><code>use Illuminate\Support\Str;

$replaced = Str::of('Laravel 6.x')-&gt;replace('6.x', '7.x');

// Laravel 7.x
</code></pre>
<p><a name="method-fluent-str-replace-array"></a></p>
<h4 id="replacearray-collection-method"><code>replaceArray</code> {#collection-method}</h4>
<p>The <code>replaceArray</code> method replaces a given value in the string sequentially using an array:</p>
<pre><code>use Illuminate\Support\Str;

$string = 'The event will take place between ? and ?';

$replaced = Str::of($string)-&gt;replaceArray('?', ['8:30', '9:00']);

// The event will take place between 8:30 and 9:00
</code></pre>
<p><a name="method-fluent-str-replace-first"></a></p>
<h4 id="replacefirst-collection-method"><code>replaceFirst</code> {#collection-method}</h4>
<p>The <code>replaceFirst</code> method replaces the first occurrence of a given value in a string:</p>
<pre><code>use Illuminate\Support\Str;

$replaced = Str::of('the quick brown fox jumps over the lazy dog')-&gt;replaceFirst('the', 'a');

// a quick brown fox jumps over the lazy dog
</code></pre>
<p><a name="method-fluent-str-replace-last"></a></p>
<h4 id="replacelast-collection-method"><code>replaceLast</code> {#collection-method}</h4>
<p>The <code>replaceLast</code> method replaces the last occurrence of a given value in a string:</p>
<pre><code>use Illuminate\Support\Str;

$replaced = Str::of('the quick brown fox jumps over the lazy dog')-&gt;replaceLast('the', 'a');

// the quick brown fox jumps over a lazy dog
</code></pre>
<p><a name="method-fluent-str-replace-matches"></a></p>
<h4 id="replacematches-collection-method"><code>replaceMatches</code> {#collection-method}</h4>
<p>The <code>replaceMatches</code> method replaces all portions of a string matching a given pattern with the given replacement string:</p>
<pre><code>use Illuminate\Support\Str;

$replaced = Str::of('(+1) 501-555-1000')-&gt;replaceMatches('/[^A-Za-z0-9]++/', '')

// '15015551000'
</code></pre>
<p>The <code>replaceMatches</code> method also accepts a Closure that will be invoked with each portion of the string matching the given party, allowing you to perform the replacement logic within the Closure and return the replaced value:</p>
<pre><code>use Illuminate\Support\Str;

$replaced = Str::of('123')-&gt;replaceMatches('/\d/', function ($match) {
    return '['.$match[0].']';
});

// '[1][2][3]'
</code></pre>
<p><a name="method-fluent-str-rtrim"></a></p>
<h4 id="rtrim-collection-method"><code>rtrim</code> {#collection-method}</h4>
<p>The <code>rtrim</code> method right trims the given string:</p>
<pre><code>use Illuminate\Support\Str;

$string = Str::of('  Laravel  ')-&gt;rtrim();

// '  Laravel'

$string = Str::of('/Laravel/')-&gt;rtrim('/');

// '/Laravel'
</code></pre>
<p><a name="method-fluent-str-singular"></a></p>
<h4 id="singular-collection-method"><code>singular</code> {#collection-method}</h4>
<p>The <code>singular</code> method converts a string to its singular form. This function currently only supports the English language:</p>
<pre><code>use Illuminate\Support\Str;

$singular = Str::of('cars')-&gt;singular();

// car

$singular = Str::of('children')-&gt;singular();

// child
</code></pre>
<p><a name="method-fluent-str-slug"></a></p>
<h4 id="slug-collection-method"><code>slug</code> {#collection-method}</h4>
<p>The <code>slug</code> method generates a URL friendly "slug" from the given string:</p>
<pre><code>use Illuminate\Support\Str;

$slug = Str::of('Laravel Framework')-&gt;slug('-');

// laravel-framework
</code></pre>
<p><a name="method-fluent-str-snake"></a></p>
<h4 id="snake-collection-method"><code>snake</code> {#collection-method}</h4>
<p>The <code>snake</code> method converts the given string to <code>snake_case</code>:</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::of('fooBar')-&gt;snake();

// foo_bar
</code></pre>
<p><a name="method-fluent-str-split"></a></p>
<h4 id="split-collection-method"><code>split</code> {#collection-method}</h4>
<p>The <code>split</code> method splits a string into a collection using a regular expression:</p>
<pre><code>use Illuminate\Support\Str;

$segments = Str::of('one, two, three')-&gt;split('/[\s,]+/');

// collect(["one", "two", "three"])
</code></pre>
<p><a name="method-fluent-str-start"></a></p>
<h4 id="start-collection-method"><code>start</code> {#collection-method}</h4>
<p>The <code>start</code> method adds a single instance of the given value to a string if it does not already start with the value:</p>
<pre><code>use Illuminate\Support\Str;

$adjusted = Str::of('this/string')-&gt;start('/');

// /this/string

$adjusted = Str::of('/this/string')-&gt;start('/');

// /this/string
</code></pre>
<p><a name="method-fluent-str-starts-with"></a></p>
<h4 id="startswith-collection-method"><code>startsWith</code> {#collection-method}</h4>
<p>The <code>startsWith</code> method determines if the given string begins with the given value:</p>
<pre><code>use Illuminate\Support\Str;

$result = Str::of('This is my name')-&gt;startsWith('This');

// true
</code></pre>
<p><a name="method-fluent-str-studly"></a></p>
<h4 id="studly-collection-method"><code>studly</code> {#collection-method}</h4>
<p>The <code>studly</code> method converts the given string to <code>StudlyCase</code>:</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::of('foo_bar')-&gt;studly();

// FooBar
</code></pre>
<p><a name="method-fluent-str-substr"></a></p>
<h4 id="substr-collection-method"><code>substr</code> {#collection-method}</h4>
<p>The <code>substr</code> method returns the portion of the string specified by the given start and length parameters:</p>
<pre><code>use Illuminate\Support\Str;

$string = Str::of('Laravel Framework')-&gt;substr(8);

// Framework

$string = Str::of('Laravel Framework')-&gt;substr(8, 5);

// Frame
</code></pre>
<p><a name="method-fluent-str-title"></a></p>
<h4 id="title-collection-method"><code>title</code> {#collection-method}</h4>
<p>The <code>title</code> method converts the given string to <code>Title Case</code>:</p>
<pre><code>use Illuminate\Support\Str;

$converted = Str::of('a nice title uses the correct case')-&gt;title();

// A Nice Title Uses The Correct Case
</code></pre>
<p><a name="method-fluent-str-trim"></a></p>
<h4 id="trim-collection-method"><code>trim</code> {#collection-method}</h4>
<p>The <code>trim</code> method trims the given string:</p>
<pre><code>use Illuminate\Support\Str;

$string = Str::of('  Laravel  ')-&gt;trim();

// 'Laravel'

$string = Str::of('/Laravel/')-&gt;trim('/');

// 'Laravel'
</code></pre>
<p><a name="method-fluent-str-ucfirst"></a></p>
<h4 id="ucfirst-collection-method"><code>ucfirst</code> {#collection-method}</h4>
<p>The <code>ucfirst</code> method returns the given string with the first character capitalized:</p>
<pre><code>use Illuminate\Support\Str;

$string = Str::of('foo bar')-&gt;ucfirst();

// Foo bar
</code></pre>
<p><a name="method-fluent-str-upper"></a></p>
<h4 id="upper-collection-method"><code>upper</code> {#collection-method}</h4>
<p>The <code>upper</code> method converts the given string to uppercase:</p>
<pre><code>use Illuminate\Support\Str;

$adjusted = Str::of('laravel')-&gt;upper();

// LARAVEL
</code></pre>
<p><a name="method-fluent-str-when"></a></p>
<h4 id="when-collection-method"><code>when</code> {#collection-method}</h4>
<p>The <code>when</code> method invokes the given Closure if a given condition is true. The Closure will receive the fluent string instance:</p>
<pre><code>use Illuminate\Support\Str;

$string = Str::of('Taylor')
                -&gt;when(true, function ($string) {
                    return $string-&gt;append(' Otwell');
                });

// 'Taylor Otwell'
</code></pre>
<p>If necessary, you may pass another Closure as the third parameter to the <code>when</code> method. This Closure will execute if the condition parameter evaluates to <code>false</code>.</p>
<p><a name="method-fluent-str-when-empty"></a></p>
<h4 id="whenempty-collection-method"><code>whenEmpty</code> {#collection-method}</h4>
<p>The <code>whenEmpty</code> method invokes the given Closure if the string is empty. If the Closure returns a value, that value will also be returned by the <code>whenEmpty</code> method. If the Closure does not return a value, the fluent string instance will be returned:</p>
<pre><code>use Illuminate\Support\Str;

$string = Str::of('  ')-&gt;whenEmpty(function ($string) {
    return $string-&gt;trim()-&gt;prepend('Laravel');
});

// 'Laravel'
</code></pre>
<p><a name="method-fluent-str-words"></a></p>
<h4 id="words-collection-method"><code>words</code> {#collection-method}</h4>
<p>The <code>words</code> method limits the number of words in a string:</p>
<pre><code>use Illuminate\Support\Str;

$string = Str::of('Perfectly balanced, as all things should be.')-&gt;words(3, ' &gt;&gt;&gt;');

// Perfectly balanced, as &gt;&gt;&gt;
</code></pre>
<p><a name="urls"></a></p>
<h2 id="urls_1">URLs</h2>
<p><a name="method-action"></a></p>
<h4 id="action-collection-method"><code>action()</code> {#collection-method}</h4>
<p>The <code>action</code> function generates a URL for the given controller action. You do not need to pass the full namespace of the controller. Instead, pass the controller class name relative to the <code>App\Http\Controllers</code> namespace:</p>
<pre><code>$url = action('HomeController@index');

$url = action([HomeController::class, 'index']);
</code></pre>
<p>If the method accepts route parameters, you may pass them as the second argument to the method:</p>
<pre><code>$url = action('UserController@profile', ['id' =&gt; 1]);
</code></pre>
<p><a name="method-asset"></a></p>
<h4 id="asset-collection-method"><code>asset()</code> {#collection-method}</h4>
<p>The <code>asset</code> function generates a URL for an asset using the current scheme of the request (HTTP or HTTPS):</p>
<pre><code>$url = asset('img/photo.jpg');
</code></pre>
<p>You can configure the asset URL host by setting the <code>ASSET_URL</code> variable in your <code>.env</code> file. This can be useful if you host your assets on an external service like Amazon S3:</p>
<pre><code>// ASSET_URL=http://example.com/assets

$url = asset('img/photo.jpg'); // http://example.com/assets/img/photo.jpg
</code></pre>
<p><a name="method-route"></a></p>
<h4 id="route-collection-method"><code>route()</code> {#collection-method}</h4>
<p>The <code>route</code> function generates a URL for the given named route:</p>
<pre><code>$url = route('routeName');
</code></pre>
<p>If the route accepts parameters, you may pass them as the second argument to the method:</p>
<pre><code>$url = route('routeName', ['id' =&gt; 1]);
</code></pre>
<p>By default, the <code>route</code> function generates an absolute URL. If you wish to generate a relative URL, you may pass <code>false</code> as the third argument:</p>
<pre><code>$url = route('routeName', ['id' =&gt; 1], false);
</code></pre>
<p><a name="method-secure-asset"></a></p>
<h4 id="secure_asset-collection-method"><code>secure_asset()</code> {#collection-method}</h4>
<p>The <code>secure_asset</code> function generates a URL for an asset using HTTPS:</p>
<pre><code>$url = secure_asset('img/photo.jpg');
</code></pre>
<p><a name="method-secure-url"></a></p>
<h4 id="secure_url-collection-method"><code>secure_url()</code> {#collection-method}</h4>
<p>The <code>secure_url</code> function generates a fully qualified HTTPS URL to the given path:</p>
<pre><code>$url = secure_url('user/profile');

$url = secure_url('user/profile', [1]);
</code></pre>
<p><a name="method-url"></a></p>
<h4 id="url-collection-method"><code>url()</code> {#collection-method}</h4>
<p>The <code>url</code> function generates a fully qualified URL to the given path:</p>
<pre><code>$url = url('user/profile');

$url = url('user/profile', [1]);
</code></pre>
<p>If no path is provided, a <code>Illuminate\Routing\UrlGenerator</code> instance is returned:</p>
<pre><code>$current = url()-&gt;current();

$full = url()-&gt;full();

$previous = url()-&gt;previous();
</code></pre>
<p><a name="miscellaneous"></a></p>
<h2 id="miscellaneous_1">Miscellaneous</h2>
<p><a name="method-abort"></a></p>
<h4 id="abort-collection-method"><code>abort()</code> {#collection-method}</h4>
<p>The <code>abort</code> function throws <a href="/docs/{{version}}/errors#http-exceptions">an HTTP exception</a> which will be rendered by the <a href="/docs/{{version}}/errors#the-exception-handler">exception handler</a>:</p>
<pre><code>abort(403);
</code></pre>
<p>You may also provide the exception's response text and custom response headers:</p>
<pre><code>abort(403, 'Unauthorized.', $headers);
</code></pre>
<p><a name="method-abort-if"></a></p>
<h4 id="abort_if-collection-method"><code>abort_if()</code> {#collection-method}</h4>
<p>The <code>abort_if</code> function throws an HTTP exception if a given boolean expression evaluates to <code>true</code>:</p>
<pre><code>abort_if(! Auth::user()-&gt;isAdmin(), 403);
</code></pre>
<p>Like the <code>abort</code> method, you may also provide the exception's response text as the third argument and an array of custom response headers as the fourth argument.</p>
<p><a name="method-abort-unless"></a></p>
<h4 id="abort_unless-collection-method"><code>abort_unless()</code> {#collection-method}</h4>
<p>The <code>abort_unless</code> function throws an HTTP exception if a given boolean expression evaluates to <code>false</code>:</p>
<pre><code>abort_unless(Auth::user()-&gt;isAdmin(), 403);
</code></pre>
<p>Like the <code>abort</code> method, you may also provide the exception's response text as the third argument and an array of custom response headers as the fourth argument.</p>
<p><a name="method-app"></a></p>
<h4 id="app-collection-method"><code>app()</code> {#collection-method}</h4>
<p>The <code>app</code> function returns the <a href="/docs/{{version}}/container">service container</a> instance:</p>
<pre><code>$container = app();
</code></pre>
<p>You may pass a class or interface name to resolve it from the container:</p>
<pre><code>$api = app('HelpSpot\API');
</code></pre>
<p><a name="method-auth"></a></p>
<h4 id="auth-collection-method"><code>auth()</code> {#collection-method}</h4>
<p>The <code>auth</code> function returns an <a href="/docs/{{version}}/authentication">authenticator</a> instance. You may use it instead of the <code>Auth</code> facade for convenience:</p>
<pre><code>$user = auth()-&gt;user();
</code></pre>
<p>If needed, you may specify which guard instance you would like to access:</p>
<pre><code>$user = auth('admin')-&gt;user();
</code></pre>
<p><a name="method-back"></a></p>
<h4 id="back-collection-method"><code>back()</code> {#collection-method}</h4>
<p>The <code>back</code> function generates a <a href="/docs/{{version}}/responses#redirects">redirect HTTP response</a> to the user's previous location:</p>
<pre><code>return back($status = 302, $headers = [], $fallback = false);

return back();
</code></pre>
<p><a name="method-bcrypt"></a></p>
<h4 id="bcrypt-collection-method"><code>bcrypt()</code> {#collection-method}</h4>
<p>The <code>bcrypt</code> function <a href="/docs/{{version}}/hashing">hashes</a> the given value using Bcrypt. You may use it as an alternative to the <code>Hash</code> facade:</p>
<pre><code>$password = bcrypt('my-secret-password');
</code></pre>
<p><a name="method-blank"></a></p>
<h4 id="blank-collection-method"><code>blank()</code> {#collection-method}</h4>
<p>The <code>blank</code> function returns whether the given value is "blank":</p>
<pre><code>blank('');
blank('   ');
blank(null);
blank(collect());

// true

blank(0);
blank(true);
blank(false);

// false
</code></pre>
<p>For the inverse of <code>blank</code>, see the <a href="#method-filled"><code>filled</code></a> method.</p>
<p><a name="method-broadcast"></a></p>
<h4 id="broadcast-collection-method"><code>broadcast()</code> {#collection-method}</h4>
<p>The <code>broadcast</code> function <a href="/docs/{{version}}/broadcasting">broadcasts</a> the given <a href="/docs/{{version}}/events">event</a> to its listeners:</p>
<pre><code>broadcast(new UserRegistered($user));
</code></pre>
<p><a name="method-cache"></a></p>
<h4 id="cache-collection-method"><code>cache()</code> {#collection-method}</h4>
<p>The <code>cache</code> function may be used to get values from the <a href="/docs/{{version}}/cache">cache</a>. If the given key does not exist in the cache, an optional default value will be returned:</p>
<pre><code>$value = cache('key');

$value = cache('key', 'default');
</code></pre>
<p>You may add items to the cache by passing an array of key / value pairs to the function. You should also pass the number of seconds or duration the cached value should be considered valid:</p>
<pre><code>cache(['key' =&gt; 'value'], 300);

cache(['key' =&gt; 'value'], now()-&gt;addSeconds(10));
</code></pre>
<p><a name="method-class-uses-recursive"></a></p>
<h4 id="class_uses_recursive-collection-method"><code>class_uses_recursive()</code> {#collection-method}</h4>
<p>The <code>class_uses_recursive</code> function returns all traits used by a class, including traits used by all of its parent classes:</p>
<pre><code>$traits = class_uses_recursive(App\User::class);
</code></pre>
<p><a name="method-collect"></a></p>
<h4 id="collect-collection-method"><code>collect()</code> {#collection-method}</h4>
<p>The <code>collect</code> function creates a <a href="/docs/{{version}}/collections">collection</a> instance from the given value:</p>
<pre><code>$collection = collect(['taylor', 'abigail']);
</code></pre>
<p><a name="method-config"></a></p>
<h4 id="config-collection-method"><code>config()</code> {#collection-method}</h4>
<p>The <code>config</code> function gets the value of a <a href="/docs/{{version}}/configuration">configuration</a> variable. The configuration values may be accessed using "dot" syntax, which includes the name of the file and the option you wish to access. A default value may be specified and is returned if the configuration option does not exist:</p>
<pre><code>$value = config('app.timezone');

$value = config('app.timezone', $default);
</code></pre>
<p>You may set configuration variables at runtime by passing an array of key / value pairs:</p>
<pre><code>config(['app.debug' =&gt; true]);
</code></pre>
<p><a name="method-cookie"></a></p>
<h4 id="cookie-collection-method"><code>cookie()</code> {#collection-method}</h4>
<p>The <code>cookie</code> function creates a new <a href="/docs/{{version}}/requests#cookies">cookie</a> instance:</p>
<pre><code>$cookie = cookie('name', 'value', $minutes);
</code></pre>
<p><a name="method-csrf-field"></a></p>
<h4 id="csrf_field-collection-method"><code>csrf_field()</code> {#collection-method}</h4>
<p>The <code>csrf_field</code> function generates an HTML <code>hidden</code> input field containing the value of the CSRF token. For example, using <a href="/docs/{{version}}/blade">Blade syntax</a>:</p>
<pre><code>{{ csrf_field() }}
</code></pre>
<p><a name="method-csrf-token"></a></p>
<h4 id="csrf_token-collection-method"><code>csrf_token()</code> {#collection-method}</h4>
<p>The <code>csrf_token</code> function retrieves the value of the current CSRF token:</p>
<pre><code>$token = csrf_token();
</code></pre>
<p><a name="method-dd"></a></p>
<h4 id="dd-collection-method"><code>dd()</code> {#collection-method}</h4>
<p>The <code>dd</code> function dumps the given variables and ends execution of the script:</p>
<pre><code>dd($value);

dd($value1, $value2, $value3, ...);
</code></pre>
<p>If you do not want to halt the execution of your script, use the <a href="#method-dump"><code>dump</code></a> function instead.</p>
<p><a name="method-dispatch"></a></p>
<h4 id="dispatch-collection-method"><code>dispatch()</code> {#collection-method}</h4>
<p>The <code>dispatch</code> function pushes the given <a href="/docs/{{version}}/queues#creating-jobs">job</a> onto the Laravel <a href="/docs/{{version}}/queues">job queue</a>:</p>
<pre><code>dispatch(new App\Jobs\SendEmails);
</code></pre>
<p><a name="method-dispatch-now"></a></p>
<h4 id="dispatch_now-collection-method"><code>dispatch_now()</code> {#collection-method}</h4>
<p>The <code>dispatch_now</code> function runs the given <a href="/docs/{{version}}/queues#creating-jobs">job</a> immediately and returns the value from its <code>handle</code> method:</p>
<pre><code>$result = dispatch_now(new App\Jobs\SendEmails);
</code></pre>
<p><a name="method-dump"></a></p>
<h4 id="dump-collection-method"><code>dump()</code> {#collection-method}</h4>
<p>The <code>dump</code> function dumps the given variables:</p>
<pre><code>dump($value);

dump($value1, $value2, $value3, ...);
</code></pre>
<p>If you want to stop executing the script after dumping the variables, use the <a href="#method-dd"><code>dd</code></a> function instead.</p>
<p><a name="method-env"></a></p>
<h4 id="env-collection-method"><code>env()</code> {#collection-method}</h4>
<p>The <code>env</code> function retrieves the value of an <a href="/docs/{{version}}/configuration#environment-configuration">environment variable</a> or returns a default value:</p>
<pre><code>$env = env('APP_ENV');

// Returns 'production' if APP_ENV is not set...
$env = env('APP_ENV', 'production');
</code></pre>
<blockquote>
<p>{note} If you execute the <code>config:cache</code> command during your deployment process, you should be sure that you are only calling the <code>env</code> function from within your configuration files. Once the configuration has been cached, the <code>.env</code> file will not be loaded and all calls to the <code>env</code> function will return <code>null</code>.</p>
</blockquote>
<p><a name="method-event"></a></p>
<h4 id="event-collection-method"><code>event()</code> {#collection-method}</h4>
<p>The <code>event</code> function dispatches the given <a href="/docs/{{version}}/events">event</a> to its listeners:</p>
<pre><code>event(new UserRegistered($user));
</code></pre>
<p><a name="method-factory"></a></p>
<h4 id="factory-collection-method"><code>factory()</code> {#collection-method}</h4>
<p>The <code>factory</code> function creates a model factory builder for a given class, name, and amount. It can be used while <a href="/docs/{{version}}/database-testing#writing-factories">testing</a> or <a href="/docs/{{version}}/seeding#using-model-factories">seeding</a>:</p>
<pre><code>$user = factory(App\User::class)-&gt;make();
</code></pre>
<p><a name="method-filled"></a></p>
<h4 id="filled-collection-method"><code>filled()</code> {#collection-method}</h4>
<p>The <code>filled</code> function returns whether the given value is not "blank":</p>
<pre><code>filled(0);
filled(true);
filled(false);

// true

filled('');
filled('   ');
filled(null);
filled(collect());

// false
</code></pre>
<p>For the inverse of <code>filled</code>, see the <a href="#method-blank"><code>blank</code></a> method.</p>
<p><a name="method-info"></a></p>
<h4 id="info-collection-method"><code>info()</code> {#collection-method}</h4>
<p>The <code>info</code> function will write information to the <a href="/docs/{{version}}/logging">log</a>:</p>
<pre><code>info('Some helpful information!');
</code></pre>
<p>An array of contextual data may also be passed to the function:</p>
<pre><code>info('User login attempt failed.', ['id' =&gt; $user-&gt;id]);
</code></pre>
<p><a name="method-logger"></a></p>
<h4 id="logger-collection-method"><code>logger()</code> {#collection-method}</h4>
<p>The <code>logger</code> function can be used to write a <code>debug</code> level message to the <a href="/docs/{{version}}/logging">log</a>:</p>
<pre><code>logger('Debug message');
</code></pre>
<p>An array of contextual data may also be passed to the function:</p>
<pre><code>logger('User has logged in.', ['id' =&gt; $user-&gt;id]);
</code></pre>
<p>A <a href="/docs/{{version}}/errors#logging">logger</a> instance will be returned if no value is passed to the function:</p>
<pre><code>logger()-&gt;error('You are not allowed here.');
</code></pre>
<p><a name="method-method-field"></a></p>
<h4 id="method_field-collection-method"><code>method_field()</code> {#collection-method}</h4>
<p>The <code>method_field</code> function generates an HTML <code>hidden</code> input field containing the spoofed value of the form's HTTP verb. For example, using <a href="/docs/{{version}}/blade">Blade syntax</a>:</p>
<pre><code>&lt;form method="POST"&gt;
    {{ method_field('DELETE') }}
&lt;/form&gt;
</code></pre>
<p><a name="method-now"></a></p>
<h4 id="now-collection-method"><code>now()</code> {#collection-method}</h4>
<p>The <code>now</code> function creates a new <code>Illuminate\Support\Carbon</code> instance for the current time:</p>
<pre><code>$now = now();
</code></pre>
<p><a name="method-old"></a></p>
<h4 id="old-collection-method"><code>old()</code> {#collection-method}</h4>
<p>The <code>old</code> function <a href="/docs/{{version}}/requests#retrieving-input">retrieves</a> an <a href="/docs/{{version}}/requests#old-input">old input</a> value flashed into the session:</p>
<pre><code>$value = old('value');

$value = old('value', 'default');
</code></pre>
<p><a name="method-optional"></a></p>
<h4 id="optional-collection-method"><code>optional()</code> {#collection-method}</h4>
<p>The <code>optional</code> function accepts any argument and allows you to access properties or call methods on that object. If the given object is <code>null</code>, properties and methods will return <code>null</code> instead of causing an error:</p>
<pre><code>return optional($user-&gt;address)-&gt;street;

{!! old('name', optional($user)-&gt;name) !!}
</code></pre>
<p>The <code>optional</code> function also accepts a Closure as its second argument. The Closure will be invoked if the value provided as the first argument is not null:</p>
<pre><code>return optional(User::find($id), function ($user) {
    return new DummyUser;
});
</code></pre>
<p><a name="method-policy"></a></p>
<h4 id="policy-collection-method"><code>policy()</code> {#collection-method}</h4>
<p>The <code>policy</code> method retrieves a <a href="/docs/{{version}}/authorization#creating-policies">policy</a> instance for a given class:</p>
<pre><code>$policy = policy(App\User::class);
</code></pre>
<p><a name="method-redirect"></a></p>
<h4 id="redirect-collection-method"><code>redirect()</code> {#collection-method}</h4>
<p>The <code>redirect</code> function returns a <a href="/docs/{{version}}/responses#redirects">redirect HTTP response</a>, or returns the redirector instance if called with no arguments:</p>
<pre><code>return redirect($to = null, $status = 302, $headers = [], $secure = null);

return redirect('/home');

return redirect()-&gt;route('route.name');
</code></pre>
<p><a name="method-report"></a></p>
<h4 id="report-collection-method"><code>report()</code> {#collection-method}</h4>
<p>The <code>report</code> function will report an exception using your <a href="/docs/{{version}}/errors#the-exception-handler">exception handler</a>'s <code>report</code> method:</p>
<pre><code>report($e);
</code></pre>
<p><a name="method-request"></a></p>
<h4 id="request-collection-method"><code>request()</code> {#collection-method}</h4>
<p>The <code>request</code> function returns the current <a href="/docs/{{version}}/requests">request</a> instance or obtains an input item:</p>
<pre><code>$request = request();

$value = request('key', $default);
</code></pre>
<p><a name="method-rescue"></a></p>
<h4 id="rescue-collection-method"><code>rescue()</code> {#collection-method}</h4>
<p>The <code>rescue</code> function executes the given Closure and catches any exceptions that occur during its execution. All exceptions that are caught will be sent to your <a href="/docs/{{version}}/errors#the-exception-handler">exception handler</a>'s <code>report</code> method; however, the request will continue processing:</p>
<pre><code>return rescue(function () {
    return $this-&gt;method();
});
</code></pre>
<p>You may also pass a second argument to the <code>rescue</code> function. This argument will be the "default" value that should be returned if an exception occurs while executing the Closure:</p>
<pre><code>return rescue(function () {
    return $this-&gt;method();
}, false);

return rescue(function () {
    return $this-&gt;method();
}, function () {
    return $this-&gt;failure();
});
</code></pre>
<p><a name="method-resolve"></a></p>
<h4 id="resolve-collection-method"><code>resolve()</code> {#collection-method}</h4>
<p>The <code>resolve</code> function resolves a given class or interface name to its instance using the <a href="/docs/{{version}}/container">service container</a>:</p>
<pre><code>$api = resolve('HelpSpot\API');
</code></pre>
<p><a name="method-response"></a></p>
<h4 id="response-collection-method"><code>response()</code> {#collection-method}</h4>
<p>The <code>response</code> function creates a <a href="/docs/{{version}}/responses">response</a> instance or obtains an instance of the response factory:</p>
<pre><code>return response('Hello World', 200, $headers);

return response()-&gt;json(['foo' =&gt; 'bar'], 200, $headers);
</code></pre>
<p><a name="method-retry"></a></p>
<h4 id="retry-collection-method"><code>retry()</code> {#collection-method}</h4>
<p>The <code>retry</code> function attempts to execute the given callback until the given maximum attempt threshold is met. If the callback does not throw an exception, its return value will be returned. If the callback throws an exception, it will automatically be retried. If the maximum attempt count is exceeded, the exception will be thrown:</p>
<pre><code>return retry(5, function () {
    // Attempt 5 times while resting 100ms in between attempts...
}, 100);
</code></pre>
<p><a name="method-session"></a></p>
<h4 id="session-collection-method"><code>session()</code> {#collection-method}</h4>
<p>The <code>session</code> function may be used to get or set <a href="/docs/{{version}}/session">session</a> values:</p>
<pre><code>$value = session('key');
</code></pre>
<p>You may set values by passing an array of key / value pairs to the function:</p>
<pre><code>session(['chairs' =&gt; 7, 'instruments' =&gt; 3]);
</code></pre>
<p>The session store will be returned if no value is passed to the function:</p>
<pre><code>$value = session()-&gt;get('key');

session()-&gt;put('key', $value);
</code></pre>
<p><a name="method-tap"></a></p>
<h4 id="tap-collection-method"><code>tap()</code> {#collection-method}</h4>
<p>The <code>tap</code> function accepts two arguments: an arbitrary <code>$value</code> and a Closure. The <code>$value</code> will be passed to the Closure and then be returned by the <code>tap</code> function. The return value of the Closure is irrelevant:</p>
<pre><code>$user = tap(User::first(), function ($user) {
    $user-&gt;name = 'taylor';

    $user-&gt;save();
});
</code></pre>
<p>If no Closure is passed to the <code>tap</code> function, you may call any method on the given <code>$value</code>. The return value of the method you call will always be <code>$value</code>, regardless of what the method actually returns in its definition. For example, the Eloquent <code>update</code> method typically returns an integer. However, we can force the method to return the model itself by chaining the <code>update</code> method call through the <code>tap</code> function:</p>
<pre><code>$user = tap($user)-&gt;update([
    'name' =&gt; $name,
    'email' =&gt; $email,
]);
</code></pre>
<p>To add a <code>tap</code> method to a class, you may add the <code>Illuminate\Support\Traits\Tappable</code> trait to the class. The <code>tap</code> method of this trait accepts a Closure as its only argument. The object instance itself will be passed to the Closure and then be returned by the <code>tap</code> method:</p>
<pre><code>return $user-&gt;tap(function ($user) {
    //
});
</code></pre>
<p><a name="method-throw-if"></a></p>
<h4 id="throw_if-collection-method"><code>throw_if()</code> {#collection-method}</h4>
<p>The <code>throw_if</code> function throws the given exception if a given boolean expression evaluates to <code>true</code>:</p>
<pre><code>throw_if(! Auth::user()-&gt;isAdmin(), AuthorizationException::class);

throw_if(
    ! Auth::user()-&gt;isAdmin(),
    AuthorizationException::class,
    'You are not allowed to access this page'
);
</code></pre>
<p><a name="method-throw-unless"></a></p>
<h4 id="throw_unless-collection-method"><code>throw_unless()</code> {#collection-method}</h4>
<p>The <code>throw_unless</code> function throws the given exception if a given boolean expression evaluates to <code>false</code>:</p>
<pre><code>throw_unless(Auth::user()-&gt;isAdmin(), AuthorizationException::class);

throw_unless(
    Auth::user()-&gt;isAdmin(),
    AuthorizationException::class,
    'You are not allowed to access this page'
);
</code></pre>
<p><a name="method-today"></a></p>
<h4 id="today-collection-method"><code>today()</code> {#collection-method}</h4>
<p>The <code>today</code> function creates a new <code>Illuminate\Support\Carbon</code> instance for the current date:</p>
<pre><code>$today = today();
</code></pre>
<p><a name="method-trait-uses-recursive"></a></p>
<h4 id="trait_uses_recursive-collection-method"><code>trait_uses_recursive()</code> {#collection-method}</h4>
<p>The <code>trait_uses_recursive</code> function returns all traits used by a trait:</p>
<pre><code>$traits = trait_uses_recursive(\Illuminate\Notifications\Notifiable::class);
</code></pre>
<p><a name="method-transform"></a></p>
<h4 id="transform-collection-method"><code>transform()</code> {#collection-method}</h4>
<p>The <code>transform</code> function executes a <code>Closure</code> on a given value if the value is not <a href="#method-blank">blank</a> and returns the result of the <code>Closure</code>:</p>
<pre><code>$callback = function ($value) {
    return $value * 2;
};

$result = transform(5, $callback);

// 10
</code></pre>
<p>A default value or <code>Closure</code> may also be passed as the third parameter to the method. This value will be returned if the given value is blank:</p>
<pre><code>$result = transform(null, $callback, 'The value is blank');

// The value is blank
</code></pre>
<p><a name="method-validator"></a></p>
<h4 id="validator-collection-method"><code>validator()</code> {#collection-method}</h4>
<p>The <code>validator</code> function creates a new <a href="/docs/{{version}}/validation">validator</a> instance with the given arguments. You may use it instead of the <code>Validator</code> facade for convenience:</p>
<pre><code>$validator = validator($data, $rules, $messages);
</code></pre>
<p><a name="method-value"></a></p>
<h4 id="value-collection-method"><code>value()</code> {#collection-method}</h4>
<p>The <code>value</code> function returns the value it is given. However, if you pass a <code>Closure</code> to the function, the <code>Closure</code> will be executed then its result will be returned:</p>
<pre><code>$result = value(true);

// true

$result = value(function () {
    return false;
});

// false
</code></pre>
<p><a name="method-view"></a></p>
<h4 id="view-collection-method"><code>view()</code> {#collection-method}</h4>
<p>The <code>view</code> function retrieves a <a href="/docs/{{version}}/views">view</a> instance:</p>
<pre><code>return view('auth.login');
</code></pre>
<p><a name="method-with"></a></p>
<h4 id="with-collection-method"><code>with()</code> {#collection-method}</h4>
<p>The <code>with</code> function returns the value it is given. If a <code>Closure</code> is passed as the second argument to the function, the <code>Closure</code> will be executed and its result will be returned:</p>
<pre><code>$callback = function ($value) {
    return (is_numeric($value)) ? $value * 2 : 0;
};

$result = with(5, $callback);

// 10

$result = with(null, $callback);

// 0

$result = with(5, null);

// 5
</code></pre>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
